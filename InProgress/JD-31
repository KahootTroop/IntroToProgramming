/*
Credit card numbers follow certain patterns. A credit card number must have between 13 and 16 digits. It must start with:
	■	4 for Visa cards 
	■	5 for Master cards 
	■	37 for American Express cards 
	■	6 for Discover cards
In 1954, Hans Luhn of IBM proposed an algorithm for validating credit card numbers. The algorithm is useful to determine whether a card number is entered correctly or whether a credit card is scanned correctly by a scanner. Credit card numbers are generated following this validity check, commonly known as the Luhn check or the Mod 10 check, which can be described as follows (for illustra- tion, consider the card number 4388576018402626):

1. Double every second digit from right to left. If doubling of a digit results in a two-digit number, add up the two digits to get a single-digit number.
2. Now add all single-digit numbers from Step 1. 4 + 4 + 8 + 2 + 3 + 1 + 7 + 8 = 37
3. Add all digits in the odd places from right to left in the card number. 6 + 6 + 0 + 8 + 0 + 7 + 8 + 3 = 38
4. Sum the results from Step 2 and Step 3. 37 + 38 = 75
5.	If the result from Step 4 is divisible by 10, the card number is valid; otherwise, it is invalid. For example, the number 4388576018402626 is invalid, but the number 4388576018410707 is valid.
*/
package jd_31;
import java.util.Scanner;
/**<h1> Exercise 06-31 was created to test and see if a number could be used as a credit card number</h1>
 * <p> Exercise 06-31 runs a series of tests to determine whether a number could be a credit card number, tests include parameters that must be met like size </p>
 * <p>Created on Jan 7 </p>
 * @author Unknown, Junit test case and Javadocs created by Isaac Bezzant
 */
public class Exercise06_31 {
	/** This method is used to get the user input for the credit card number to be tested and call on isValid to see if the number is valid
	*/
	public static void main(String[] args) {
		Scanner input = new Scanner(System.in);
		System.out.print("Enter a credit card number as a long integer: ");
		long number = input.nextLong();
		
		if (isValid(number))
			System.out.println(number + " is valid");
		else
			System.out.println(number + " is invalid"); 
	}
	/**This method is used to call on the other methods to test a number against the parameters to see if it could be a valid credit card number (Step 5)
	* <pre>Examples: 
	* {@code isValid(1234567891112L) returns: False
	*   isValid(4388576018410707L) returns: True} </pre>
	*   @param number (long; the users given number to be tested for validity)
	*   @return isValid (boolean; true if meets all parameters, false if does not meet all parameters)
	*/
	public static boolean isValid(long number) {
		return  (getSize(number) >= 13) && (getSize(number) <= 16) && 
				(prefixMatched(number, 4) || prefixMatched(number, 5) ||
				prefixMatched(number, 6) || prefixMatched(number, 37)) && 
			 (sumOfDoubleEvenPlace(number) + sumOfOddPlace(number)) % 10 == 0;
	}
	/**This method is used to add all of the numbers with the getDigit method (Step 2)
	* <pre>Examples:
	* {@code sumOfDoubleEvenPlace(4388576018410707L) returns: 29
	* sumOfDoubleEvenPlace(1234567891011L) returns: 26} </pre>
	* @param number (long; the users given number to be tested)
	* @return result (int; the sum of the numbers from using the getDigit method)
	*/
	public static int sumOfDoubleEvenPlace(long number) {
		int result = 0;
		
		number = number / 10; // Starting from the second digit from left
		while (number != 0) {
			result += getDigit((int)((number % 10) * 2));
			number = number / 100; // Move to the next even place
		}
		
		return result;
	}
	/**This method is used to return the number if it is a single digit, otherwise return the two digits added together (step 1)
	 * <pre>Examples:
	 * {@code getDigit(1234567891) returns: 123456790
	 * getDigit(438857601) returns: 43885761 
	 * } </pre>
	 * @param number (int; the number given by the user to be tested)
	 * @return {@code number % 10 + (number / 10)} (int; the number if it is a single digit, or the sum of the two digits)
	 */
	public static int getDigit(int number) {
		return number % 10 + (number / 10);
	}
	
	/**This method is used to get the sum of all the odd place digits in the number (step 3)
	 * <pre>Examples:
	 * {@code sumOfOddPlace(4388576018410707L) returns: 41
	 *  sumOfOddPlace(1234567891011L) returns: 26} </pre>
	 * @param number (long; user input for card number to be tested)
	 * @return result (int; the sum of odd place digits in the number)
	 */
	public static int sumOfOddPlace(long number) {
		int result = 0;
	 
		while (number != 0) {
			result += (int)(number % 10);
			number = number / 100; // Move two positions to the left
		}
		
		return result;
	}
	/**This method is used to determine if the number d is a prefix for the number 
	 * <pre>Examples: 
	 * {@code prefixMatched(1234567891, 1) returns: True
	 * prefixedMatched(4288576018410707L, 3) returns: False} </pre>
	 * @param number (long; the number from the user to be tested)
	 * @param d (int; the number to be tested as a prefix for the number)
	 * @return {@code getPrefix(number, getSize(d)) ==d} (boolean; whether the number d is a prefix for the number or not)  
	 */
	public static boolean prefixMatched(long number, int d) {
		return getPrefix(number, getSize(d)) == d;
	}
	
	/**This method is used to total the number of digits in d
	 * <pre> Examples: 
	 * {@code getSize(12345678910) returns: 11
	 *  getSize(1110987654321) returns: 13 } </pre> 
	 * @param d (long; the number to be tested for number of digits)
	 * @return numberOfDigits (int; the amount of digits in d)
	 */
	public static int getSize(long d) {
		int numberOfDigits = 0;
		
		while (d != 0) {
			numberOfDigits++;
			d = d / 10;
		}
		
		return numberOfDigits;
	}
	
	/** This method is used to get the first k digits in the number as the prefix, or return the number if k is less than the length of the number
	 * <pre>Examples: 
	 * {@code getPrefix(12345678910, 3) Returns: 123
	 *  getPrefix(12345678911, 5) Returns: 12345} </pre>
	 * @param number (long; number to be tested from user)
	 * @param k (int; the amount of the first numbers to be returned as the prefix)
	 * @return result (long; the prefix, or the first k digits in the number)
	 */
	public static long getPrefix(long number, int k) {
		long result = number;
		
		for (int i = 0; i < getSize(number) - k; i++)
			result /= 10;
		
		return result;
	}
}
